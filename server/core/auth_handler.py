"""
Cookie and authentication handler for browser sessions.
"""
import os
import json
import tempfile
from pathlib import Path
from typing import Optional
from http.cookiejar import MozillaCookieJar
from datetime import datetime

import config


class AuthHandler:
    """Handles cookie extraction and management for authenticated downloads."""

    def __init__(self):
        self.cookie_dir = config.TEMP_COOKIE_DIR

    def save_cookies_from_extension(
        self,
        cookies,
        domain: str,
    ) -> str:
        """
        Save cookies received from browser extension to a Netscape cookie file.

        Args:
            cookies: Either a list of cookie dicts from extension with keys:
                     name, value, domain, path, expirationDate, secure, httpOnly
                     OR a string in format "name=value; name2=value2"
            domain: The domain these cookies are for

        Returns:
            Path to the temporary cookie file
        """
        # Create a unique filename for this session
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_domain = domain.replace(".", "_").replace("/", "_")
        cookie_file = self.cookie_dir / f"cookies_{safe_domain}_{timestamp}.txt"

        # Convert string format to list of dicts if necessary
        cookie_list = []
        if isinstance(cookies, str):
            # Parse "name=value; name2=value2" format
            if cookies.strip():
                for part in cookies.split(";"):
                    part = part.strip()
                    if "=" in part:
                        name, value = part.split("=", 1)
                        cookie_list.append({
                            "name": name.strip(),
                            "value": value.strip(),
                            "domain": domain,
                            "path": "/",
                            "secure": False,
                            "expirationDate": 0
                        })
        elif isinstance(cookies, list):
            cookie_list = cookies
        else:
            cookie_list = []

        # Write in Netscape cookie file format
        with open(cookie_file, "w") as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# https://curl.haxx.se/docs/http-cookies.html\n")
            f.write("# This file was generated by video-downloader\n\n")

            for cookie in cookie_list:
                # Netscape format: domain, include_subdomains, path, secure, expiry, name, value
                cookie_domain = cookie.get("domain", domain) if isinstance(cookie, dict) else domain
                include_subdomains = "TRUE" if cookie_domain.startswith(".") else "FALSE"
                path = cookie.get("path", "/") if isinstance(cookie, dict) else "/"
                secure = "TRUE" if (isinstance(cookie, dict) and cookie.get("secure", False)) else "FALSE"
                expiry = str(int(cookie.get("expirationDate", 0))) if isinstance(cookie, dict) else "0"
                name = cookie.get("name", "") if isinstance(cookie, dict) else ""
                value = cookie.get("value", "") if isinstance(cookie, dict) else ""

                if name and value:
                    f.write(f"{cookie_domain}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n")

        return str(cookie_file)

    def get_browser_cookies(self, browser: str = "chrome", domain: Optional[str] = None) -> str:
        """
        Extract cookies from local browser using browser-cookie3.

        Args:
            browser: Browser to extract from ('chrome', 'firefox', 'opera', 'edge')
            domain: Optional domain filter

        Returns:
            Path to the temporary cookie file
        """
        try:
            import browser_cookie3

            browser_funcs = {
                "chrome": browser_cookie3.chrome,
                "firefox": browser_cookie3.firefox,
                "opera": browser_cookie3.opera,
                "edge": browser_cookie3.edge,
                "chromium": browser_cookie3.chromium,
            }

            if browser not in browser_funcs:
                raise ValueError(f"Unsupported browser: {browser}")

            cj = browser_funcs[browser](domain_name=domain)

            # Save to Netscape format file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_domain = (domain or "all").replace(".", "_").replace("/", "_")
            cookie_file = self.cookie_dir / f"browser_{browser}_{safe_domain}_{timestamp}.txt"

            # Write cookies
            with open(cookie_file, "w") as f:
                f.write("# Netscape HTTP Cookie File\n")
                f.write("# https://curl.haxx.se/docs/http-cookies.html\n\n")

                for cookie in cj:
                    include_subdomains = "TRUE" if cookie.domain.startswith(".") else "FALSE"
                    secure = "TRUE" if cookie.secure else "FALSE"
                    expiry = str(cookie.expires) if cookie.expires else "0"

                    f.write(f"{cookie.domain}\t{include_subdomains}\t{cookie.path}\t{secure}\t{expiry}\t{cookie.name}\t{cookie.value}\n")

            return str(cookie_file)

        except ImportError:
            raise RuntimeError("browser-cookie3 not installed")
        except Exception as e:
            raise RuntimeError(f"Failed to extract browser cookies: {e}")

    def cleanup_cookie_file(self, cookie_file: str):
        """Delete a temporary cookie file."""
        try:
            path = Path(cookie_file)
            if path.exists() and path.parent == self.cookie_dir:
                path.unlink()
        except Exception:
            pass

    def cleanup_old_cookies(self, max_age_hours: int = 1):
        """Delete cookie files older than max_age_hours."""
        try:
            now = datetime.now()
            for cookie_file in self.cookie_dir.glob("*.txt"):
                age = now - datetime.fromtimestamp(cookie_file.stat().st_mtime)
                if age.total_seconds() > max_age_hours * 3600:
                    cookie_file.unlink()
        except Exception:
            pass
